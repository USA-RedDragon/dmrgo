/*
Code generated by dmrgen.

ETSI TS 102 361-1 V2.5.1 (2017-10) - 9.1.8 Unconfirmed Data Header
ETSI TS 102 361-1 V2.5.1 (2017-10) - 9.1.8 Data Header PDU

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/dmr/bit"
	crc "github.com/USA-RedDragon/dmrgo/dmr/crc"
	fec "github.com/USA-RedDragon/dmrgo/dmr/fec"
	layer2Elements "github.com/USA-RedDragon/dmrgo/dmr/layer2/elements"
)

// DecodeUnconfirmedDataHeader decodes a UnconfirmedDataHeader per ETSI TS 102 361-1 V2.5.1 (2017-10) - 9.1.8 Unconfirmed Data Header
func DecodeUnconfirmedDataHeader(data [80]bit.Bit) (UnconfirmedDataHeader, fec.FECResult) {
	var result UnconfirmedDataHeader
	var fecResult fec.FECResult
	result.Group = bit.BitsToBool(data[:], 0)
	result.ResponseRequested = bit.BitsToBool(data[:], 1)
	result.Reserved = bit.BitsToBool(data[:], 2)
	var _tmpPadOctetCount uint8
	_tmpPadOctetCount = bit.BitsToUint8(data[:], 3, 1)
	_tmpPadOctetCount <<= 4
	_tmpPadOctetCount |= bit.BitsToUint8(data[:], 12, 4)
	result.PadOctetCount = _tmpPadOctetCount
	copy(result.LLIDDestination[:], data[16:40])
	copy(result.LLIDSource[:], data[40:64])
	result.FullMessage = bit.BitsToBool(data[:], 64)
	result.BlocksToFollow = bit.BitsToUint8(data[:], 65, 7)
	copy(result.Reserved2[:], data[72:76])
	result.FragmentSequenceNumber = bit.BitsToUint8(data[:], 76, 4)
	return result, fecResult
}

// EncodeUnconfirmedDataHeader encodes a UnconfirmedDataHeader per ETSI TS 102 361-1 V2.5.1 (2017-10) - 9.1.8 Unconfirmed Data Header
func EncodeUnconfirmedDataHeader(s *UnconfirmedDataHeader) [80]bit.Bit {
	var data [80]bit.Bit
	if s.Group {
		data[0] = 1
	}
	if s.ResponseRequested {
		data[1] = 1
	}
	if s.Reserved {
		data[2] = 1
	}
	copy(data[3:4], bit.BitsFromUint8((uint8(s.PadOctetCount))>>4, 1))
	copy(data[12:16], bit.BitsFromUint8(s.PadOctetCount, 4))
	copy(data[16:40], s.LLIDDestination[:])
	copy(data[40:64], s.LLIDSource[:])
	if s.FullMessage {
		data[64] = 1
	}
	copy(data[65:72], bit.BitsFromUint8(s.BlocksToFollow, 7))
	copy(data[72:76], s.Reserved2[:])
	copy(data[76:80], bit.BitsFromUint8(s.FragmentSequenceNumber, 4))
	return data
}

func (s *UnconfirmedDataHeader) ToString() string {
	return fmt.Sprintf("UnconfirmedDataHeader{ Group: %t, ResponseRequested: %t, Reserved: %t, PadOctetCount: %d, LLIDDestination: %v, LLIDSource: %v, FullMessage: %t, BlocksToFollow: %d, Reserved2: %v, FragmentSequenceNumber: %d }", s.Group, s.ResponseRequested, s.Reserved, s.PadOctetCount, s.LLIDDestination, s.LLIDSource, s.FullMessage, s.BlocksToFollow, s.Reserved2, s.FragmentSequenceNumber)
}

// DecodeDataHeader decodes a DataHeader per ETSI TS 102 361-1 V2.5.1 (2017-10) - 9.1.8 Data Header PDU
func DecodeDataHeader(data [96]bit.Bit) (DataHeader, fec.FECResult) {
	var result DataHeader
	var _packedBytes [12]byte
	for i := range 12 {
		for j := range 8 {
			_packedBytes[i] <<= 1
			_packedBytes[i] |= byte(data[i*8+j])
		}
	}
	var fecResult fec.FECResult
	fecResult.BitsChecked = 96
	if !crc.CheckCRCCCITT(_packedBytes[:]) {
		fecResult.Uncorrectable = true
	}
	result.FEC = fecResult
	result.crc = uint16(_packedBytes[10])<<8 | uint16(_packedBytes[11])
	result.Format = Format(bit.BitsToUint8(data[:], 4, 4))
	var _dispatchBits [80]bit.Bit
	copy(_dispatchBits[:], data[0:80])
	switch result.Format {
	case FormatUnconfirmed:
		_decoded, _ := DecodeUnconfirmedDataHeader(_dispatchBits)
		result.UnconfirmedDataHeader = &_decoded
	}
	return result, fecResult
}

// EncodeDataHeader encodes a DataHeader per ETSI TS 102 361-1 V2.5.1 (2017-10) - 9.1.8 Data Header PDU
func EncodeDataHeader(s *DataHeader) [96]bit.Bit {
	var data [96]bit.Bit
	copy(data[4:8], bit.BitsFromUint8(uint8(s.Format), 4))
	switch {
	case s.UnconfirmedDataHeader != nil:
		_pduBits := EncodeUnconfirmedDataHeader(s.UnconfirmedDataHeader)
		copy(data[0:80], _pduBits[:])
	}
	var _encBytes [10]byte
	for i := range 10 {
		for j := range 8 {
			_encBytes[i] <<= 1
			_encBytes[i] |= byte(data[i*8+j])
		}
	}
	_crcVal := crc.CalculateCRCCCITT(_encBytes[:])
	_crcHigh := byte(_crcVal >> 8)
	_crcLow := byte(_crcVal)
	for j := range 8 {
		data[80+j] = bit.Bit((_crcHigh >> (7 - j)) & 1)
	}
	for j := range 8 {
		data[88+j] = bit.Bit((_crcLow >> (7 - j)) & 1)
	}
	return data
}

func (s *DataHeader) ToString() string {
	_ret := "DataHeader{ "
	_ret += fmt.Sprintf("DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, Format: %d, ", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.Format)
	switch {
	case s.UnconfirmedDataHeader != nil:
		_ret += s.UnconfirmedDataHeader.ToString()
	}
	_ret += " }"
	return _ret
}
