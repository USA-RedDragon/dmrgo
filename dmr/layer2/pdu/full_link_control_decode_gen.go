// Code generated by dmrgen. DO NOT EDIT.

package pdu

import (
	bit "github.com/USA-RedDragon/dmrgo/dmr/bit"
	fec "github.com/USA-RedDragon/dmrgo/dmr/fec"
	elements "github.com/USA-RedDragon/dmrgo/dmr/layer3/elements"
	"math"
)

func DecodeFLCGroupVoice(data [56]bit.Bit) (FLCGroupVoice, fec.FECResult) {
	var result FLCGroupVoice
	var fecResult fec.FECResult
	var _serviceOptionsBits [8]bit.Bit
	copy(_serviceOptionsBits[:], data[0:8])
	result.ServiceOptions = *elements.NewServiceOptionsFromBits(_serviceOptionsBits)
	result.GroupAddress = bit.BitsToInt(data[:], 8, 24)
	result.SourceAddress = bit.BitsToInt(data[:], 32, 24)
	return result, fecResult
}

func EncodeFLCGroupVoice(s *FLCGroupVoice) [56]bit.Bit {
	var data [56]bit.Bit
	copy(data[0:8], bit.BitsFromUint8(s.ServiceOptions.ToByte(), 8))
	copy(data[8:32], bit.BitsFromUint32(uint32(s.GroupAddress), 24))
	copy(data[32:56], bit.BitsFromUint32(uint32(s.SourceAddress), 24))
	return data
}
func DecodeFLCUnitToUnit(data [56]bit.Bit) (FLCUnitToUnit, fec.FECResult) {
	var result FLCUnitToUnit
	var fecResult fec.FECResult
	var _serviceOptionsBits [8]bit.Bit
	copy(_serviceOptionsBits[:], data[0:8])
	result.ServiceOptions = *elements.NewServiceOptionsFromBits(_serviceOptionsBits)
	result.TargetAddress = bit.BitsToInt(data[:], 8, 24)
	result.SourceAddress = bit.BitsToInt(data[:], 32, 24)
	return result, fecResult
}

func EncodeFLCUnitToUnit(s *FLCUnitToUnit) [56]bit.Bit {
	var data [56]bit.Bit
	copy(data[0:8], bit.BitsFromUint8(s.ServiceOptions.ToByte(), 8))
	copy(data[8:32], bit.BitsFromUint32(uint32(s.TargetAddress), 24))
	copy(data[32:56], bit.BitsFromUint32(uint32(s.SourceAddress), 24))
	return data
}
func DecodeFLCGPSInfo(data [56]bit.Bit) (FLCGPSInfo, fec.FECResult) {
	var result FLCGPSInfo
	var fecResult fec.FECResult
	var _positionErrorBits [3]bit.Bit
	copy(_positionErrorBits[:], data[4:7])
	result.PositionError = *elements.NewPositionErrorFromBits(_positionErrorBits)
	result.Longitude = float32(bit.BitsToInt(data[:], 7, 25)) * float32(360.0/math.Pow(2.0, 25.0))
	result.Latitude = float32(bit.BitsToInt(data[:], 32, 24)) * float32(180.0/math.Pow(2.0, 24.0))
	return result, fecResult
}

func EncodeFLCGPSInfo(s *FLCGPSInfo) [56]bit.Bit {
	var data [56]bit.Bit
	copy(data[7:32], bit.BitsFromUint32(uint32(s.Longitude/float32(360.0/math.Pow(2.0, 25.0))), 25))
	copy(data[32:56], bit.BitsFromUint32(uint32(s.Latitude/float32(180.0/math.Pow(2.0, 24.0))), 24))
	return data
}
func DecodeFLCTalkerAliasHeader(data [56]bit.Bit) (FLCTalkerAliasHeader, fec.FECResult) {
	var result FLCTalkerAliasHeader
	var fecResult fec.FECResult
	var _talkerAliasDataFormatBits [2]bit.Bit
	copy(_talkerAliasDataFormatBits[:], data[0:2])
	result.TalkerAliasDataFormat = elements.NewTalkerAliasDataFormatFromBits(_talkerAliasDataFormatBits)
	result.TalkerAliasDataLength = bit.BitsToInt(data[:], 2, 6)
	result.TalkerAliasDataMSB = bit.BitsToBool(data[:], 7)
	copy(result.TalkerAliasData[:], data[8:56])
	return result, fecResult
}

func EncodeFLCTalkerAliasHeader(s *FLCTalkerAliasHeader) [56]bit.Bit {
	var data [56]bit.Bit
	copy(data[2:8], bit.BitsFromUint32(uint32(s.TalkerAliasDataLength), 6))
	if s.TalkerAliasDataMSB {
		data[7] = 1
	}
	copy(data[8:56], s.TalkerAliasData[:])
	return data
}
func DecodeFLCTalkerAliasBlock(data [56]bit.Bit) (FLCTalkerAliasBlock, fec.FECResult) {
	var result FLCTalkerAliasBlock
	var fecResult fec.FECResult
	copy(result.TalkerAliasData[:], data[0:56])
	return result, fecResult
}

func EncodeFLCTalkerAliasBlock(s *FLCTalkerAliasBlock) [56]bit.Bit {
	var data [56]bit.Bit
	copy(data[0:56], s.TalkerAliasData[:])
	return data
}
