/*
Code generated by dmrgen.

ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Header
ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Continuation

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/v2/bit"
	crc "github.com/USA-RedDragon/dmrgo/v2/crc"
	fec "github.com/USA-RedDragon/dmrgo/v2/fec"
	layer2Elements "github.com/USA-RedDragon/dmrgo/v2/layer2/elements"
)

// DecodeMBCHeader decodes a MBCHeader per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Header
func DecodeMBCHeader(data [96]bit.Bit) (MBCHeader, fec.FECResult) {
	var result MBCHeader
	var _packedBytes [12]byte
	for i := range 12 {
		for j := range 8 {
			_packedBytes[i] <<= 1
			_packedBytes[i] |= byte(data[i*8+j])
		}
	}
	_packedBytes[10] ^= uint8(0xaa)
	_packedBytes[11] ^= uint8(0xaa)
	var fecResult fec.FECResult
	fecResult.BitsChecked = 96
	if !crc.CheckCRCCCITT(_packedBytes[:]) {
		fecResult.Uncorrectable = true
	}
	result.FEC = fecResult
	result.crc = uint16(_packedBytes[10])<<8 | uint16(_packedBytes[11])
	result.LastBlock = bit.BitsToBool(data[:], 0)
	result.ProtectFlag = bit.BitsToBool(data[:], 1)
	result.CSBKOpcode = CSBKOpcode(bit.BitsToUint8(data[:], 2, 6))
	result.FID = bit.BitsToUint8(data[:], 8, 8)
	copy(result.Data[:], data[16:80])
	return result, fecResult
}

// EncodeMBCHeader encodes a MBCHeader per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Header
func EncodeMBCHeader(s *MBCHeader) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	if s.ProtectFlag {
		data[1] = 1
	}
	copy(data[2:8], bit.BitsFromUint8(uint8(s.CSBKOpcode), 6))
	copy(data[8:16], bit.BitsFromUint8(uint8(s.FID), 8))
	copy(data[16:80], s.Data[:])
	var _encBytes [10]byte
	for i := range 10 {
		for j := range 8 {
			_encBytes[i] <<= 1
			_encBytes[i] |= byte(data[i*8+j])
		}
	}
	_crcVal := crc.CalculateCRCCCITT(_encBytes[:])
	_crcHigh := byte(_crcVal >> 8)
	_crcLow := byte(_crcVal)
	_crcHigh ^= uint8(0xaa)
	_crcLow ^= uint8(0xaa)
	for j := range 8 {
		data[80+j] = bit.Bit((_crcHigh >> (7 - j)) & 1)
	}
	for j := range 8 {
		data[88+j] = bit.Bit((_crcLow >> (7 - j)) & 1)
	}
	return data
}

func (s *MBCHeader) ToString() string {
	return fmt.Sprintf("MBCHeader{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, ProtectFlag: %t, CSBKOpcode: %d, FID: %d, Data: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.ProtectFlag, s.CSBKOpcode, s.FID, s.Data)
}

// DecodeMBCContinuation decodes a MBCContinuation per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Continuation
func DecodeMBCContinuation(data [96]bit.Bit) (MBCContinuation, fec.FECResult) {
	var result MBCContinuation
	var fecResult fec.FECResult
	result.LastBlock = bit.BitsToBool(data[:], 0)
	copy(result.Data[:], data[1:96])
	return result, fecResult
}

// EncodeMBCContinuation encodes a MBCContinuation per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Continuation
func EncodeMBCContinuation(s *MBCContinuation) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	copy(data[1:96], s.Data[:])
	return data
}

func (s *MBCContinuation) ToString() string {
	return fmt.Sprintf("MBCContinuation{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, Data: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.Data)
}
