/*
Code generated by dmrgen.

ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Header
ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Continuation
ETSI TS 102 361-4 — §7.1.1.1.2, Table 7.16
ETSI TS 102 361-4 — §7.1.1.1.3.1, Table 7.18
ETSI TS 102 361-4 — §7.1.1.1.5.1, Table 7.21
ETSI TS 102 361-4 — §7.2.19.3.1, Table 7.72

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/v2/bit"
	crc "github.com/USA-RedDragon/dmrgo/v2/crc"
	fec "github.com/USA-RedDragon/dmrgo/v2/fec"
	layer2Elements "github.com/USA-RedDragon/dmrgo/v2/layer2/elements"
)

// DecodeMBCHeader decodes a MBCHeader per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Header
func DecodeMBCHeader(data [96]bit.Bit) (MBCHeader, fec.FECResult) {
	var result MBCHeader
	var _packedBytes [12]byte
	for i := range 12 {
		for j := range 8 {
			_packedBytes[i] <<= 1
			_packedBytes[i] |= byte(data[i*8+j])
		}
	}
	_packedBytes[10] ^= uint8(0xaa)
	_packedBytes[11] ^= uint8(0xaa)
	var fecResult fec.FECResult
	fecResult.BitsChecked = 96
	if !crc.CheckCRCCCITT(_packedBytes[:]) {
		fecResult.Uncorrectable = true
	}
	result.FEC = fecResult
	result.crc = uint16(_packedBytes[10])<<8 | uint16(_packedBytes[11])
	result.LastBlock = bit.BitsToBool(data[:], 0)
	result.ProtectFlag = bit.BitsToBool(data[:], 1)
	result.CSBKOpcode = CSBKOpcode(bit.BitsToUint8(data[:], 2, 6))
	result.FID = bit.BitsToUint8(data[:], 8, 8)
	copy(result.Data[:], data[16:80])
	return result, fecResult
}

// EncodeMBCHeader encodes a MBCHeader per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Header
func EncodeMBCHeader(s *MBCHeader) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	if s.ProtectFlag {
		data[1] = 1
	}
	copy(data[2:8], bit.BitsFromUint8(uint8(s.CSBKOpcode), 6))
	copy(data[8:16], bit.BitsFromUint8(uint8(s.FID), 8))
	copy(data[16:80], s.Data[:])
	var _encBytes [10]byte
	for i := range 10 {
		for j := range 8 {
			_encBytes[i] <<= 1
			_encBytes[i] |= byte(data[i*8+j])
		}
	}
	_crcVal := crc.CalculateCRCCCITT(_encBytes[:])
	_crcHigh := byte(_crcVal >> 8)
	_crcLow := byte(_crcVal)
	_crcHigh ^= uint8(0xaa)
	_crcLow ^= uint8(0xaa)
	for j := range 8 {
		data[80+j] = bit.Bit((_crcHigh >> (7 - j)) & 1)
	}
	for j := range 8 {
		data[88+j] = bit.Bit((_crcLow >> (7 - j)) & 1)
	}
	return data
}

func (s *MBCHeader) ToString() string {
	return fmt.Sprintf("MBCHeader{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, ProtectFlag: %t, CSBKOpcode: %d, FID: %d, Data: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.ProtectFlag, s.CSBKOpcode, s.FID, s.Data)
}

// DecodeMBCContinuation decodes a MBCContinuation per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Continuation
func DecodeMBCContinuation(data [96]bit.Bit) (MBCContinuation, fec.FECResult) {
	var result MBCContinuation
	var fecResult fec.FECResult
	result.LastBlock = bit.BitsToBool(data[:], 0)
	copy(result.Data[:], data[1:96])
	return result, fecResult
}

// EncodeMBCContinuation encodes a MBCContinuation per ETSI TS 102 361-1 - 7.4.1 Multi Block Control (MBC) Continuation
func EncodeMBCContinuation(s *MBCContinuation) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	copy(data[1:96], s.Data[:])
	return data
}

func (s *MBCContinuation) ToString() string {
	return fmt.Sprintf("MBCContinuation{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, Data: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.Data)
}

// DecodeCGAPContinuation decodes a CGAPContinuation per ETSI TS 102 361-4 — §7.1.1.1.2, Table 7.16
func DecodeCGAPContinuation(data [96]bit.Bit) (CGAPContinuation, fec.FECResult) {
	var result CGAPContinuation
	var fecResult fec.FECResult
	result.LastBlock = bit.BitsToBool(data[:], 0)
	result.ProtectFlag = bit.BitsToBool(data[:], 1)
	result.CSBKOpcode = CSBKOpcode(bit.BitsToUint8(data[:], 2, 6))
	result.Reserved1 = bit.BitsToUint8(data[:], 8, 4)
	result.ColourCode = bit.BitsToUint8(data[:], 12, 4)
	result.Cdeftype = bit.BitsToUint8(data[:], 16, 4)
	result.Reserved2 = bit.BitsToUint8(data[:], 20, 2)
	copy(result.CdefParms[:], data[22:80])
	return result, fecResult
}

// EncodeCGAPContinuation encodes a CGAPContinuation per ETSI TS 102 361-4 — §7.1.1.1.2, Table 7.16
func EncodeCGAPContinuation(s *CGAPContinuation) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	if s.ProtectFlag {
		data[1] = 1
	}
	copy(data[2:8], bit.BitsFromUint8(uint8(s.CSBKOpcode), 6))
	copy(data[8:12], bit.BitsFromUint8(s.Reserved1, 4))
	copy(data[12:16], bit.BitsFromUint8(s.ColourCode, 4))
	copy(data[16:20], bit.BitsFromUint8(s.Cdeftype, 4))
	copy(data[20:22], bit.BitsFromUint8(s.Reserved2, 2))
	copy(data[22:80], s.CdefParms[:])
	return data
}

func (s *CGAPContinuation) ToString() string {
	return fmt.Sprintf("CGAPContinuation{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, ProtectFlag: %t, CSBKOpcode: %d, Reserved1: %d, ColourCode: %d, Cdeftype: %d, Reserved2: %d, CdefParms: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.ProtectFlag, s.CSBKOpcode, s.Reserved1, s.ColourCode, s.Cdeftype, s.Reserved2, s.CdefParms)
}

// DecodeMVAPContinuation decodes a MVAPContinuation per ETSI TS 102 361-4 — §7.1.1.1.3.1, Table 7.18
func DecodeMVAPContinuation(data [96]bit.Bit) (MVAPContinuation, fec.FECResult) {
	var result MVAPContinuation
	var fecResult fec.FECResult
	result.LastBlock = bit.BitsToBool(data[:], 0)
	result.ProtectFlag = bit.BitsToBool(data[:], 1)
	result.CSBKOpcode = CSBKOpcode(bit.BitsToUint8(data[:], 2, 6))
	result.Reserved1 = bit.BitsToUint8(data[:], 8, 4)
	result.ColourCode = bit.BitsToUint8(data[:], 12, 4)
	result.Cdeftype = bit.BitsToUint8(data[:], 16, 4)
	result.Reserved2 = bit.BitsToUint8(data[:], 20, 2)
	copy(result.CdefParms[:], data[22:80])
	return result, fecResult
}

// EncodeMVAPContinuation encodes a MVAPContinuation per ETSI TS 102 361-4 — §7.1.1.1.3.1, Table 7.18
func EncodeMVAPContinuation(s *MVAPContinuation) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	if s.ProtectFlag {
		data[1] = 1
	}
	copy(data[2:8], bit.BitsFromUint8(uint8(s.CSBKOpcode), 6))
	copy(data[8:12], bit.BitsFromUint8(s.Reserved1, 4))
	copy(data[12:16], bit.BitsFromUint8(s.ColourCode, 4))
	copy(data[16:20], bit.BitsFromUint8(s.Cdeftype, 4))
	copy(data[20:22], bit.BitsFromUint8(s.Reserved2, 2))
	copy(data[22:80], s.CdefParms[:])
	return data
}

func (s *MVAPContinuation) ToString() string {
	return fmt.Sprintf("MVAPContinuation{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, ProtectFlag: %t, CSBKOpcode: %d, Reserved1: %d, ColourCode: %d, Cdeftype: %d, Reserved2: %d, CdefParms: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.ProtectFlag, s.CSBKOpcode, s.Reserved1, s.ColourCode, s.Cdeftype, s.Reserved2, s.CdefParms)
}

// DecodeBCAPContinuation decodes a BCAPContinuation per ETSI TS 102 361-4 — §7.1.1.1.5.1, Table 7.21
func DecodeBCAPContinuation(data [96]bit.Bit) (BCAPContinuation, fec.FECResult) {
	var result BCAPContinuation
	var fecResult fec.FECResult
	result.LastBlock = bit.BitsToBool(data[:], 0)
	result.ProtectFlag = bit.BitsToBool(data[:], 1)
	result.CSBKOpcode = CSBKOpcode(bit.BitsToUint8(data[:], 2, 6))
	result.Reserved1 = bit.BitsToUint8(data[:], 8, 8)
	result.Cdeftype = bit.BitsToUint8(data[:], 16, 4)
	result.Reserved2 = bit.BitsToUint8(data[:], 20, 2)
	copy(result.CdefParms[:], data[22:80])
	return result, fecResult
}

// EncodeBCAPContinuation encodes a BCAPContinuation per ETSI TS 102 361-4 — §7.1.1.1.5.1, Table 7.21
func EncodeBCAPContinuation(s *BCAPContinuation) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	if s.ProtectFlag {
		data[1] = 1
	}
	copy(data[2:8], bit.BitsFromUint8(uint8(s.CSBKOpcode), 6))
	copy(data[8:16], bit.BitsFromUint8(uint8(s.Reserved1), 8))
	copy(data[16:20], bit.BitsFromUint8(s.Cdeftype, 4))
	copy(data[20:22], bit.BitsFromUint8(s.Reserved2, 2))
	copy(data[22:80], s.CdefParms[:])
	return data
}

func (s *BCAPContinuation) ToString() string {
	return fmt.Sprintf("BCAPContinuation{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, ProtectFlag: %t, CSBKOpcode: %d, Reserved1: %d, Cdeftype: %d, Reserved2: %d, CdefParms: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.ProtectFlag, s.CSBKOpcode, s.Reserved1, s.Cdeftype, s.Reserved2, s.CdefParms)
}

// DecodeVNAPContinuation decodes a VNAPContinuation per ETSI TS 102 361-4 — §7.2.19.3.1, Table 7.72
func DecodeVNAPContinuation(data [96]bit.Bit) (VNAPContinuation, fec.FECResult) {
	var result VNAPContinuation
	var fecResult fec.FECResult
	result.LastBlock = bit.BitsToBool(data[:], 0)
	result.ProtectFlag = bit.BitsToBool(data[:], 1)
	result.CSBKOpcode = CSBKOpcode(bit.BitsToUint8(data[:], 2, 6))
	result.Reserved1 = bit.BitsToUint8(data[:], 8, 4)
	result.ColourCode = bit.BitsToUint8(data[:], 12, 4)
	result.Cdeftype = bit.BitsToUint8(data[:], 16, 4)
	result.Reserved2 = bit.BitsToUint8(data[:], 20, 2)
	copy(result.CdefParms[:], data[22:80])
	return result, fecResult
}

// EncodeVNAPContinuation encodes a VNAPContinuation per ETSI TS 102 361-4 — §7.2.19.3.1, Table 7.72
func EncodeVNAPContinuation(s *VNAPContinuation) [96]bit.Bit {
	var data [96]bit.Bit
	if s.LastBlock {
		data[0] = 1
	}
	if s.ProtectFlag {
		data[1] = 1
	}
	copy(data[2:8], bit.BitsFromUint8(uint8(s.CSBKOpcode), 6))
	copy(data[8:12], bit.BitsFromUint8(s.Reserved1, 4))
	copy(data[12:16], bit.BitsFromUint8(s.ColourCode, 4))
	copy(data[16:20], bit.BitsFromUint8(s.Cdeftype, 4))
	copy(data[20:22], bit.BitsFromUint8(s.Reserved2, 2))
	copy(data[22:80], s.CdefParms[:])
	return data
}

func (s *VNAPContinuation) ToString() string {
	return fmt.Sprintf("VNAPContinuation{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, LastBlock: %t, ProtectFlag: %t, CSBKOpcode: %d, Reserved1: %d, ColourCode: %d, Cdeftype: %d, Reserved2: %d, CdefParms: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.LastBlock, s.ProtectFlag, s.CSBKOpcode, s.Reserved1, s.ColourCode, s.Cdeftype, s.Reserved2, s.CdefParms)
}
