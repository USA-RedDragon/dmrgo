/*
Code generated by dmrgen.

ETSI TS 102 361-1 - 9.1.8 Unconfirmed Data Header
ETSI TS 102 361-1 - 9.1.8 Data Header PDU
ETSI TS 102 361-1 - Table 9.10: Confirmed Data Header (C_HEAD) PDU content
ETSI TS 102 361-1 - Table 9.13: Response Packet Header (C_RHEAD) PDU content
ETSI TS 102 361-1 - Table 9.17C: Defined Data Header (DD_HEAD) PDU content
ETSI TS 102 361-1 - Table 9.17B: Raw Data Header (R_HEAD) PDU content
ETSI TS 102 361-1 - Table 9.17A: Status/Precoded Data Header (SP_HEAD) PDU content

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/v2/bit"
	crc "github.com/USA-RedDragon/dmrgo/v2/crc"
	fec "github.com/USA-RedDragon/dmrgo/v2/fec"
	layer2Elements "github.com/USA-RedDragon/dmrgo/v2/layer2/elements"
)

// DecodeUnconfirmedDataHeader decodes a UnconfirmedDataHeader per ETSI TS 102 361-1 - 9.1.8 Unconfirmed Data Header
func DecodeUnconfirmedDataHeader(data [80]bit.Bit) (UnconfirmedDataHeader, fec.FECResult) {
	var result UnconfirmedDataHeader
	var fecResult fec.FECResult
	result.Group = bit.BitsToBool(data[:], 0)
	result.ResponseRequested = bit.BitsToBool(data[:], 1)
	result.Reserved = bit.BitsToBool(data[:], 2)
	var _tmpPadOctetCount uint8
	_tmpPadOctetCount = bit.BitsToUint8(data[:], 3, 1)
	_tmpPadOctetCount <<= 4
	_tmpPadOctetCount |= bit.BitsToUint8(data[:], 12, 4)
	result.PadOctetCount = _tmpPadOctetCount
	result.SAP = bit.BitsToUint8(data[:], 8, 4)
	copy(result.LLIDDestination[:], data[16:40])
	copy(result.LLIDSource[:], data[40:64])
	result.FullMessage = bit.BitsToBool(data[:], 64)
	result.BlocksToFollow = bit.BitsToUint8(data[:], 65, 7)
	copy(result.Reserved2[:], data[72:76])
	result.FragmentSequenceNumber = bit.BitsToUint8(data[:], 76, 4)
	return result, fecResult
}

// EncodeUnconfirmedDataHeader encodes a UnconfirmedDataHeader per ETSI TS 102 361-1 - 9.1.8 Unconfirmed Data Header
func EncodeUnconfirmedDataHeader(s *UnconfirmedDataHeader) [80]bit.Bit {
	var data [80]bit.Bit
	if s.Group {
		data[0] = 1
	}
	if s.ResponseRequested {
		data[1] = 1
	}
	if s.Reserved {
		data[2] = 1
	}
	copy(data[3:4], bit.BitsFromUint8((uint8(s.PadOctetCount))>>4, 1))
	copy(data[12:16], bit.BitsFromUint8(s.PadOctetCount, 4))
	copy(data[8:12], bit.BitsFromUint8(s.SAP, 4))
	copy(data[16:40], s.LLIDDestination[:])
	copy(data[40:64], s.LLIDSource[:])
	if s.FullMessage {
		data[64] = 1
	}
	copy(data[65:72], bit.BitsFromUint8(s.BlocksToFollow, 7))
	copy(data[72:76], s.Reserved2[:])
	copy(data[76:80], bit.BitsFromUint8(s.FragmentSequenceNumber, 4))
	return data
}

func (s *UnconfirmedDataHeader) ToString() string {
	return fmt.Sprintf("UnconfirmedDataHeader{ Group: %t, ResponseRequested: %t, Reserved: %t, PadOctetCount: %d, SAP: %d, LLIDDestination: %v, LLIDSource: %v, FullMessage: %t, BlocksToFollow: %d, Reserved2: %v, FragmentSequenceNumber: %d }", s.Group, s.ResponseRequested, s.Reserved, s.PadOctetCount, s.SAP, s.LLIDDestination, s.LLIDSource, s.FullMessage, s.BlocksToFollow, s.Reserved2, s.FragmentSequenceNumber)
}

// DecodeDataHeader decodes a DataHeader per ETSI TS 102 361-1 - 9.1.8 Data Header PDU
func DecodeDataHeader(data [96]bit.Bit) (DataHeader, fec.FECResult) {
	var result DataHeader
	var _packedBytes [12]byte
	for i := range 12 {
		for j := range 8 {
			_packedBytes[i] <<= 1
			_packedBytes[i] |= byte(data[i*8+j])
		}
	}
	_packedBytes[10] ^= uint8(0xcc)
	_packedBytes[11] ^= uint8(0xcc)
	var fecResult fec.FECResult
	fecResult.BitsChecked = 96
	if !crc.CheckCRCCCITT(_packedBytes[:]) {
		fecResult.Uncorrectable = true
	}
	result.FEC = fecResult
	result.crc = uint16(_packedBytes[10])<<8 | uint16(_packedBytes[11])
	result.Format = Format(bit.BitsToUint8(data[:], 4, 4))
	var _tmpAppendedBlocks uint8
	_tmpAppendedBlocks = bit.BitsToUint8(data[:], 2, 2)
	_tmpAppendedBlocks <<= 4
	_tmpAppendedBlocks |= bit.BitsToUint8(data[:], 12, 4)
	result.AppendedBlocks = _tmpAppendedBlocks
	var _dispatchBits [80]bit.Bit
	copy(_dispatchBits[:], data[0:80])
	switch result.Format {
	case FormatUnconfirmed:
		_decoded, _ := DecodeUnconfirmedDataHeader(_dispatchBits)
		result.UnconfirmedDataHeader = &_decoded
	case FormatConfirmed:
		_decoded, _ := DecodeConfirmedDataHeader(_dispatchBits)
		result.ConfirmedDataHeader = &_decoded
	case FormatResponsePacket:
		_decoded, _ := DecodeResponsePacketHeader(_dispatchBits)
		result.ResponsePacketHeader = &_decoded
	case FormatShortDataDefined:
		_decoded, _ := DecodeDefinedDataHeader(_dispatchBits)
		result.DefinedDataHeader = &_decoded
	case FormatShortDataRawOrStatusPrecoded:
		if result.AppendedBlocks == 0 {
			_decoded, _ := DecodeStatusPrecodedHeader(_dispatchBits)
			result.StatusPrecodedHeader = &_decoded
		} else {
			_decoded, _ := DecodeRawDataHeader(_dispatchBits)
			result.RawDataHeader = &_decoded
		}
	}
	return result, fecResult
}

// EncodeDataHeader encodes a DataHeader per ETSI TS 102 361-1 - 9.1.8 Data Header PDU
func EncodeDataHeader(s *DataHeader) [96]bit.Bit {
	var data [96]bit.Bit
	switch {
	case s.UnconfirmedDataHeader != nil:
		_pduBits := EncodeUnconfirmedDataHeader(s.UnconfirmedDataHeader)
		copy(data[0:80], _pduBits[:])
	case s.ConfirmedDataHeader != nil:
		_pduBits := EncodeConfirmedDataHeader(s.ConfirmedDataHeader)
		copy(data[0:80], _pduBits[:])
	case s.ResponsePacketHeader != nil:
		_pduBits := EncodeResponsePacketHeader(s.ResponsePacketHeader)
		copy(data[0:80], _pduBits[:])
	case s.DefinedDataHeader != nil:
		_pduBits := EncodeDefinedDataHeader(s.DefinedDataHeader)
		copy(data[0:80], _pduBits[:])
	case s.StatusPrecodedHeader != nil:
		_pduBits := EncodeStatusPrecodedHeader(s.StatusPrecodedHeader)
		copy(data[0:80], _pduBits[:])
	case s.RawDataHeader != nil:
		_pduBits := EncodeRawDataHeader(s.RawDataHeader)
		copy(data[0:80], _pduBits[:])
	}
	copy(data[4:8], bit.BitsFromUint8(uint8(s.Format), 4))
	var _encBytes [10]byte
	for i := range 10 {
		for j := range 8 {
			_encBytes[i] <<= 1
			_encBytes[i] |= byte(data[i*8+j])
		}
	}
	_crcVal := crc.CalculateCRCCCITT(_encBytes[:])
	_crcHigh := byte(_crcVal >> 8)
	_crcLow := byte(_crcVal)
	_crcHigh ^= uint8(0xcc)
	_crcLow ^= uint8(0xcc)
	for j := range 8 {
		data[80+j] = bit.Bit((_crcHigh >> (7 - j)) & 1)
	}
	for j := range 8 {
		data[88+j] = bit.Bit((_crcLow >> (7 - j)) & 1)
	}
	return data
}

func (s *DataHeader) ToString() string {
	_ret := "DataHeader{ "
	_ret += fmt.Sprintf("DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, Format: %d, AppendedBlocks: %d, ", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.Format, s.AppendedBlocks)
	switch {
	case s.UnconfirmedDataHeader != nil:
		_ret += s.UnconfirmedDataHeader.ToString()
	case s.ConfirmedDataHeader != nil:
		_ret += s.ConfirmedDataHeader.ToString()
	case s.ResponsePacketHeader != nil:
		_ret += s.ResponsePacketHeader.ToString()
	case s.DefinedDataHeader != nil:
		_ret += s.DefinedDataHeader.ToString()
	case s.StatusPrecodedHeader != nil:
		_ret += s.StatusPrecodedHeader.ToString()
	case s.RawDataHeader != nil:
		_ret += s.RawDataHeader.ToString()
	}
	_ret += " }"
	return _ret
}

// DecodeConfirmedDataHeader decodes a ConfirmedDataHeader per ETSI TS 102 361-1 - Table 9.10: Confirmed Data Header (C_HEAD) PDU content
func DecodeConfirmedDataHeader(data [80]bit.Bit) (ConfirmedDataHeader, fec.FECResult) {
	var result ConfirmedDataHeader
	var fecResult fec.FECResult
	result.Group = bit.BitsToBool(data[:], 0)
	result.ResponseRequested = bit.BitsToBool(data[:], 1)
	var _tmpPadOctetCount uint8
	_tmpPadOctetCount = bit.BitsToUint8(data[:], 3, 1)
	_tmpPadOctetCount <<= 4
	_tmpPadOctetCount |= bit.BitsToUint8(data[:], 12, 4)
	result.PadOctetCount = _tmpPadOctetCount
	result.SAP = bit.BitsToUint8(data[:], 8, 4)
	result.LLIDDestination = bit.BitsToInt(data[:], 16, 24)
	result.LLIDSource = bit.BitsToInt(data[:], 40, 24)
	result.FullMessageFlag = bit.BitsToBool(data[:], 64)
	result.BlocksToFollow = bit.BitsToUint8(data[:], 65, 7)
	result.ReSynchronizeFlag = bit.BitsToBool(data[:], 72)
	result.SendSequenceNumber = bit.BitsToUint8(data[:], 73, 3)
	result.FragmentSequenceNumber = bit.BitsToUint8(data[:], 76, 4)
	return result, fecResult
}

// EncodeConfirmedDataHeader encodes a ConfirmedDataHeader per ETSI TS 102 361-1 - Table 9.10: Confirmed Data Header (C_HEAD) PDU content
func EncodeConfirmedDataHeader(s *ConfirmedDataHeader) [80]bit.Bit {
	var data [80]bit.Bit
	if s.Group {
		data[0] = 1
	}
	if s.ResponseRequested {
		data[1] = 1
	}
	copy(data[3:4], bit.BitsFromUint8((uint8(s.PadOctetCount))>>4, 1))
	copy(data[12:16], bit.BitsFromUint8(s.PadOctetCount, 4))
	copy(data[8:12], bit.BitsFromUint8(s.SAP, 4))
	copy(data[16:40], bit.BitsFromUint32(uint32(s.LLIDDestination), 24))
	copy(data[40:64], bit.BitsFromUint32(uint32(s.LLIDSource), 24))
	if s.FullMessageFlag {
		data[64] = 1
	}
	copy(data[65:72], bit.BitsFromUint8(s.BlocksToFollow, 7))
	if s.ReSynchronizeFlag {
		data[72] = 1
	}
	copy(data[73:76], bit.BitsFromUint8(s.SendSequenceNumber, 3))
	copy(data[76:80], bit.BitsFromUint8(s.FragmentSequenceNumber, 4))
	return data
}

func (s *ConfirmedDataHeader) ToString() string {
	return fmt.Sprintf("ConfirmedDataHeader{ Group: %t, ResponseRequested: %t, PadOctetCount: %d, SAP: %d, LLIDDestination: %d, LLIDSource: %d, FullMessageFlag: %t, BlocksToFollow: %d, ReSynchronizeFlag: %t, SendSequenceNumber: %d, FragmentSequenceNumber: %d }", s.Group, s.ResponseRequested, s.PadOctetCount, s.SAP, s.LLIDDestination, s.LLIDSource, s.FullMessageFlag, s.BlocksToFollow, s.ReSynchronizeFlag, s.SendSequenceNumber, s.FragmentSequenceNumber)
}

// DecodeResponsePacketHeader decodes a ResponsePacketHeader per ETSI TS 102 361-1 - Table 9.13: Response Packet Header (C_RHEAD) PDU content
func DecodeResponsePacketHeader(data [80]bit.Bit) (ResponsePacketHeader, fec.FECResult) {
	var result ResponsePacketHeader
	var fecResult fec.FECResult
	result.SAP = bit.BitsToUint8(data[:], 8, 4)
	result.LLIDDestination = bit.BitsToInt(data[:], 16, 24)
	result.LLIDSource = bit.BitsToInt(data[:], 40, 24)
	result.BlocksToFollow = bit.BitsToUint8(data[:], 65, 7)
	result.ResponseClass = bit.BitsToUint8(data[:], 72, 2)
	result.ResponseType = bit.BitsToUint8(data[:], 74, 3)
	result.ResponseStatus = bit.BitsToUint8(data[:], 77, 3)
	return result, fecResult
}

// EncodeResponsePacketHeader encodes a ResponsePacketHeader per ETSI TS 102 361-1 - Table 9.13: Response Packet Header (C_RHEAD) PDU content
func EncodeResponsePacketHeader(s *ResponsePacketHeader) [80]bit.Bit {
	var data [80]bit.Bit
	copy(data[8:12], bit.BitsFromUint8(s.SAP, 4))
	copy(data[16:40], bit.BitsFromUint32(uint32(s.LLIDDestination), 24))
	copy(data[40:64], bit.BitsFromUint32(uint32(s.LLIDSource), 24))
	copy(data[65:72], bit.BitsFromUint8(s.BlocksToFollow, 7))
	copy(data[72:74], bit.BitsFromUint8(s.ResponseClass, 2))
	copy(data[74:77], bit.BitsFromUint8(s.ResponseType, 3))
	copy(data[77:80], bit.BitsFromUint8(s.ResponseStatus, 3))
	return data
}

func (s *ResponsePacketHeader) ToString() string {
	return fmt.Sprintf("ResponsePacketHeader{ SAP: %d, LLIDDestination: %d, LLIDSource: %d, BlocksToFollow: %d, ResponseClass: %d, ResponseType: %d, ResponseStatus: %d }", s.SAP, s.LLIDDestination, s.LLIDSource, s.BlocksToFollow, s.ResponseClass, s.ResponseType, s.ResponseStatus)
}

// DecodeDefinedDataHeader decodes a DefinedDataHeader per ETSI TS 102 361-1 - Table 9.17C: Defined Data Header (DD_HEAD) PDU content
func DecodeDefinedDataHeader(data [80]bit.Bit) (DefinedDataHeader, fec.FECResult) {
	var result DefinedDataHeader
	var fecResult fec.FECResult
	result.Group = bit.BitsToBool(data[:], 0)
	result.ResponseRequested = bit.BitsToBool(data[:], 1)
	var _tmpAppendedBlocks uint8
	_tmpAppendedBlocks = bit.BitsToUint8(data[:], 2, 2)
	_tmpAppendedBlocks <<= 4
	_tmpAppendedBlocks |= bit.BitsToUint8(data[:], 12, 4)
	result.AppendedBlocks = _tmpAppendedBlocks
	result.SAP = bit.BitsToUint8(data[:], 8, 4)
	result.LLIDDestination = bit.BitsToInt(data[:], 16, 24)
	result.LLIDSource = bit.BitsToInt(data[:], 40, 24)
	result.DefinedData = bit.BitsToUint8(data[:], 64, 6)
	result.SARQ = bit.BitsToBool(data[:], 70)
	result.FullMessageFlag = bit.BitsToBool(data[:], 71)
	result.BitPadding = bit.BitsToUint8(data[:], 72, 8)
	return result, fecResult
}

// EncodeDefinedDataHeader encodes a DefinedDataHeader per ETSI TS 102 361-1 - Table 9.17C: Defined Data Header (DD_HEAD) PDU content
func EncodeDefinedDataHeader(s *DefinedDataHeader) [80]bit.Bit {
	var data [80]bit.Bit
	if s.Group {
		data[0] = 1
	}
	if s.ResponseRequested {
		data[1] = 1
	}
	copy(data[2:4], bit.BitsFromUint8((uint8(s.AppendedBlocks))>>4, 2))
	copy(data[12:16], bit.BitsFromUint8(s.AppendedBlocks, 4))
	copy(data[8:12], bit.BitsFromUint8(s.SAP, 4))
	copy(data[16:40], bit.BitsFromUint32(uint32(s.LLIDDestination), 24))
	copy(data[40:64], bit.BitsFromUint32(uint32(s.LLIDSource), 24))
	copy(data[64:70], bit.BitsFromUint8(s.DefinedData, 6))
	if s.SARQ {
		data[70] = 1
	}
	if s.FullMessageFlag {
		data[71] = 1
	}
	copy(data[72:80], bit.BitsFromUint8(s.BitPadding, 8))
	return data
}

func (s *DefinedDataHeader) ToString() string {
	return fmt.Sprintf("DefinedDataHeader{ Group: %t, ResponseRequested: %t, AppendedBlocks: %d, SAP: %d, LLIDDestination: %d, LLIDSource: %d, DefinedData: %d, SARQ: %t, FullMessageFlag: %t, BitPadding: %d }", s.Group, s.ResponseRequested, s.AppendedBlocks, s.SAP, s.LLIDDestination, s.LLIDSource, s.DefinedData, s.SARQ, s.FullMessageFlag, s.BitPadding)
}

// DecodeRawDataHeader decodes a RawDataHeader per ETSI TS 102 361-1 - Table 9.17B: Raw Data Header (R_HEAD) PDU content
func DecodeRawDataHeader(data [80]bit.Bit) (RawDataHeader, fec.FECResult) {
	var result RawDataHeader
	var fecResult fec.FECResult
	result.Group = bit.BitsToBool(data[:], 0)
	result.ResponseRequested = bit.BitsToBool(data[:], 1)
	var _tmpAppendedBlocks uint8
	_tmpAppendedBlocks = bit.BitsToUint8(data[:], 2, 2)
	_tmpAppendedBlocks <<= 4
	_tmpAppendedBlocks |= bit.BitsToUint8(data[:], 12, 4)
	result.AppendedBlocks = _tmpAppendedBlocks
	result.SAP = bit.BitsToUint8(data[:], 8, 4)
	result.LLIDDestination = bit.BitsToInt(data[:], 16, 24)
	result.LLIDSource = bit.BitsToInt(data[:], 40, 24)
	result.SourcePort = bit.BitsToUint8(data[:], 64, 3)
	result.DestinationPort = bit.BitsToUint8(data[:], 67, 3)
	result.SARQ = bit.BitsToBool(data[:], 70)
	result.FullMessageFlag = bit.BitsToBool(data[:], 71)
	result.BitPadding = bit.BitsToUint8(data[:], 72, 8)
	return result, fecResult
}

// EncodeRawDataHeader encodes a RawDataHeader per ETSI TS 102 361-1 - Table 9.17B: Raw Data Header (R_HEAD) PDU content
func EncodeRawDataHeader(s *RawDataHeader) [80]bit.Bit {
	var data [80]bit.Bit
	if s.Group {
		data[0] = 1
	}
	if s.ResponseRequested {
		data[1] = 1
	}
	copy(data[2:4], bit.BitsFromUint8((uint8(s.AppendedBlocks))>>4, 2))
	copy(data[12:16], bit.BitsFromUint8(s.AppendedBlocks, 4))
	copy(data[8:12], bit.BitsFromUint8(s.SAP, 4))
	copy(data[16:40], bit.BitsFromUint32(uint32(s.LLIDDestination), 24))
	copy(data[40:64], bit.BitsFromUint32(uint32(s.LLIDSource), 24))
	copy(data[64:67], bit.BitsFromUint8(s.SourcePort, 3))
	copy(data[67:70], bit.BitsFromUint8(s.DestinationPort, 3))
	if s.SARQ {
		data[70] = 1
	}
	if s.FullMessageFlag {
		data[71] = 1
	}
	copy(data[72:80], bit.BitsFromUint8(s.BitPadding, 8))
	return data
}

func (s *RawDataHeader) ToString() string {
	return fmt.Sprintf("RawDataHeader{ Group: %t, ResponseRequested: %t, AppendedBlocks: %d, SAP: %d, LLIDDestination: %d, LLIDSource: %d, SourcePort: %d, DestinationPort: %d, SARQ: %t, FullMessageFlag: %t, BitPadding: %d }", s.Group, s.ResponseRequested, s.AppendedBlocks, s.SAP, s.LLIDDestination, s.LLIDSource, s.SourcePort, s.DestinationPort, s.SARQ, s.FullMessageFlag, s.BitPadding)
}

// DecodeStatusPrecodedHeader decodes a StatusPrecodedHeader per ETSI TS 102 361-1 - Table 9.17A: Status/Precoded Data Header (SP_HEAD) PDU content
func DecodeStatusPrecodedHeader(data [80]bit.Bit) (StatusPrecodedHeader, fec.FECResult) {
	var result StatusPrecodedHeader
	var fecResult fec.FECResult
	result.Group = bit.BitsToBool(data[:], 0)
	result.ResponseRequested = bit.BitsToBool(data[:], 1)
	result.SAP = bit.BitsToUint8(data[:], 8, 4)
	result.LLIDDestination = bit.BitsToInt(data[:], 16, 24)
	result.LLIDSource = bit.BitsToInt(data[:], 40, 24)
	result.SourcePort = bit.BitsToUint8(data[:], 64, 3)
	result.DestinationPort = bit.BitsToUint8(data[:], 67, 3)
	result.StatusPrecoded = bit.BitsToUint16(data[:], 70, 10)
	return result, fecResult
}

// EncodeStatusPrecodedHeader encodes a StatusPrecodedHeader per ETSI TS 102 361-1 - Table 9.17A: Status/Precoded Data Header (SP_HEAD) PDU content
func EncodeStatusPrecodedHeader(s *StatusPrecodedHeader) [80]bit.Bit {
	var data [80]bit.Bit
	if s.Group {
		data[0] = 1
	}
	if s.ResponseRequested {
		data[1] = 1
	}
	copy(data[8:12], bit.BitsFromUint8(s.SAP, 4))
	copy(data[16:40], bit.BitsFromUint32(uint32(s.LLIDDestination), 24))
	copy(data[40:64], bit.BitsFromUint32(uint32(s.LLIDSource), 24))
	copy(data[64:67], bit.BitsFromUint8(s.SourcePort, 3))
	copy(data[67:70], bit.BitsFromUint8(s.DestinationPort, 3))
	copy(data[70:80], bit.BitsFromUint16(s.StatusPrecoded, 10))
	return data
}

func (s *StatusPrecodedHeader) ToString() string {
	return fmt.Sprintf("StatusPrecodedHeader{ Group: %t, ResponseRequested: %t, SAP: %d, LLIDDestination: %d, LLIDSource: %d, SourcePort: %d, DestinationPort: %d, StatusPrecoded: %d }", s.Group, s.ResponseRequested, s.SAP, s.LLIDDestination, s.LLIDSource, s.SourcePort, s.DestinationPort, s.StatusPrecoded)
}
