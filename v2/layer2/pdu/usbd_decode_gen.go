/*
Code generated by dmrgen.

ETSI TS 102 361-1 - 8.2.3.1 Unified Single Block Data (USBD)

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/v2/bit"
	crc "github.com/USA-RedDragon/dmrgo/v2/crc"
	fec "github.com/USA-RedDragon/dmrgo/v2/fec"
	layer2Elements "github.com/USA-RedDragon/dmrgo/v2/layer2/elements"
)

// DecodeUnifiedSingleBlockData decodes a UnifiedSingleBlockData per ETSI TS 102 361-1 - 8.2.3.1 Unified Single Block Data (USBD)
func DecodeUnifiedSingleBlockData(data [96]bit.Bit) (UnifiedSingleBlockData, fec.FECResult) {
	var result UnifiedSingleBlockData
	var _packedBytes [12]byte
	for i := range 12 {
		for j := range 8 {
			_packedBytes[i] <<= 1
			_packedBytes[i] |= byte(data[i*8+j])
		}
	}
	_packedBytes[10] ^= uint8(0x33)
	_packedBytes[11] ^= uint8(0x33)
	var fecResult fec.FECResult
	fecResult.BitsChecked = 96
	if !crc.CheckCRCCCITT(_packedBytes[:]) {
		fecResult.Uncorrectable = true
	}
	result.FEC = fecResult
	result.crc = uint16(_packedBytes[10])<<8 | uint16(_packedBytes[11])
	result.ServiceType = ServiceType(bit.BitsToUint8(data[:], 0, 4))
	copy(result.Payload[:], data[4:80])
	return result, fecResult
}

// EncodeUnifiedSingleBlockData encodes a UnifiedSingleBlockData per ETSI TS 102 361-1 - 8.2.3.1 Unified Single Block Data (USBD)
func EncodeUnifiedSingleBlockData(s *UnifiedSingleBlockData) [96]bit.Bit {
	var data [96]bit.Bit
	copy(data[0:4], bit.BitsFromUint8(uint8(s.ServiceType), 4))
	copy(data[4:80], s.Payload[:])
	var _encBytes [10]byte
	for i := range 10 {
		for j := range 8 {
			_encBytes[i] <<= 1
			_encBytes[i] |= byte(data[i*8+j])
		}
	}
	_crcVal := crc.CalculateCRCCCITT(_encBytes[:])
	_crcHigh := byte(_crcVal >> 8)
	_crcLow := byte(_crcVal)
	_crcHigh ^= uint8(0x33)
	_crcLow ^= uint8(0x33)
	for j := range 8 {
		data[80+j] = bit.Bit((_crcHigh >> (7 - j)) & 1)
	}
	for j := range 8 {
		data[88+j] = bit.Bit((_crcLow >> (7 - j)) & 1)
	}
	return data
}

func (s *UnifiedSingleBlockData) ToString() string {
	return fmt.Sprintf("UnifiedSingleBlockData{ DataType: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t}, ServiceType: %d, Payload: %v }", layer2Elements.DataTypeToName(s.DataType), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable, s.ServiceType, s.Payload)
}
