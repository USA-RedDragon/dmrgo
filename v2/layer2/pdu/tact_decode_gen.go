/*
Code generated by dmrgen.

ETSI TS 102 361-1 - 9.1.4 TACT PDU

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/v2/bit"
	enums "github.com/USA-RedDragon/dmrgo/v2/enums"
	fec "github.com/USA-RedDragon/dmrgo/v2/fec"
	hamming "github.com/USA-RedDragon/dmrgo/v2/fec/hamming"
)

// DecodeTACT decodes a TACT per ETSI TS 102 361-1 - 9.1.4 TACT PDU
func DecodeTACT(data [7]bit.Bit) (TACT, fec.FECResult) {
	var result TACT
	corrected, fecResult := hamming.Decode743(data)
	result.FEC = fecResult
	if !fecResult.Uncorrectable {
		data = corrected
	}
	result.AccessType = bit.BitsToBool(data[:], 0)
	result.TDMAChannel = bit.BitsToBool(data[:], 1)
	result.LCSS = enums.LCSSFromInt(bit.BitsToInt(data[:], 2, 2))
	return result, fecResult
}

// EncodeTACT encodes a TACT per ETSI TS 102 361-1 - 9.1.4 TACT PDU
func EncodeTACT(s *TACT) [7]bit.Bit {
	var data [4]bit.Bit
	if s.AccessType {
		data[0] = 1
	}
	if s.TDMAChannel {
		data[1] = 1
	}
	copy(data[2:4], bit.BitsFromUint8(uint8(s.LCSS), 2))
	return hamming.Encode(bit.BitsToValue(data[:]))
}

func (s *TACT) ToString() string {
	return fmt.Sprintf("TACT{ AccessType: %t, TDMAChannel: %t, LCSS: %s, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t} }", s.AccessType, s.TDMAChannel, enums.LCSSToName(s.LCSS), s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable)
}
