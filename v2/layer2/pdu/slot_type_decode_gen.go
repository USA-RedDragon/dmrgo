/*
Code generated by dmrgen.

ETSI TS 102 361-1 - 9.1.3 Slot Type (SLOT) PDU

DO NOT EDIT.
*/

package pdu

import (
	"fmt"
	bit "github.com/USA-RedDragon/dmrgo/v2/bit"
	fec "github.com/USA-RedDragon/dmrgo/v2/fec"
	golay "github.com/USA-RedDragon/dmrgo/v2/fec/golay"
	layer2Elements "github.com/USA-RedDragon/dmrgo/v2/layer2/elements"
)

// DecodeSlotType decodes a SlotType per ETSI TS 102 361-1 - 9.1.3 Slot Type (SLOT) PDU
func DecodeSlotType(data [20]bit.Bit) (SlotType, fec.FECResult) {
	var result SlotType
	corrected, fecResult := golay.DecodeGolay2087(data)
	result.FEC = fecResult
	if !fecResult.Uncorrectable {
		data = corrected
	}
	result.ColorCode = bit.BitsToInt(data[:], 0, 4)
	result.DataType = layer2Elements.DataType(bit.BitsToUint8(data[:], 4, 4))
	return result, fecResult
}

// EncodeSlotType encodes a SlotType per ETSI TS 102 361-1 - 9.1.3 Slot Type (SLOT) PDU
func EncodeSlotType(s *SlotType) [20]bit.Bit {
	var data [8]bit.Bit
	copy(data[0:4], bit.BitsFromUint32(uint32(s.ColorCode), 4))
	copy(data[4:8], bit.BitsFromUint8(uint8(s.DataType), 4))
	return golay.Encode(bit.BitsToValue(data[:]))
}

func (s *SlotType) ToString() string {
	return fmt.Sprintf("SlotType{ ColorCode: %d, DataType: %d, FEC: {BitsChecked: %d, ErrorsCorrected: %d, Uncorrectable: %t} }", s.ColorCode, s.DataType, s.FEC.BitsChecked, s.FEC.ErrorsCorrected, s.FEC.Uncorrectable)
}
