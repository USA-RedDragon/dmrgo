package generate

import (
	"fmt"
	"path/filepath"
	"reflect"

	"github.com/USA-RedDragon/dmrgo/cmd/tablegen/compute"
	"github.com/dave/jennifer/jen"
)

func WriteAll(tables *compute.Tables, dmrRoot string) error {
	if err := writeFile(dmrRoot, "fec/bptc", "bptc",
		writeTable("dm", tables.DM[:]),
		jen.Line(),
		jen.Line(),
		writeTable("hamming15_11_syndrome_table", tables.Hamming15_11Syndrome[:]),
		jen.Line(),
		jen.Line(),
		writeTable("hamming13_9_syndrome_table", tables.Hamming13_9Syndrome[:]),
		jen.Line(),
		jen.Line(),
		writeTable("hamming16_11_syndrome_table", tables.Hamming16_11Syndrome[:]),
		jen.Line(),
		jen.Line(),
		writeTable("hamming17_12_syndrome_table", tables.Hamming17_12Syndrome[:]),
		jen.Line(),
		jen.Line(),
		writeTable("single_burst_bptc_interleave", tables.SingleBurstBPTCInterleave[:]),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "fec/hamming", "hamming",
		writeTable("hamming743_syndrome_table", tables.Hamming743Syndrome[:]),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "crc", "crc",
		writeTable("ccitt16_0x1021", tables.CRCCCITT[:]),
		jen.Line(),
		jen.Line(),
		writeTable("crc32_0x04C11DB7", tables.CRC32[:]),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "vocoder", "vocoder",
		writeTable("AMBE_SCRAMBLE_TABLE", tables.AMBEScrambleTable[:]),
		jen.Line(),
		jen.Line(),
		writeTable("aTable", tables.ATable),
		jen.Line(),
		jen.Line(),
		writeTable("bTable", tables.BTable),
		jen.Line(),
		jen.Line(),
		writeTable("cTable", tables.CTable),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "fec/reed_solomon", "reedsolomon",
		writeTable("galois_exp_table", tables.GaloisExp[:]),
		jen.Line(),
		jen.Line(),
		writeTable("galois_log_table", tables.GaloisLog[:]),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "fec/golay", "golay",
		writeTable("golay_20_8_7_table", tables.Golay20_8_7Encoding),
		jen.Line(),
		jen.Line(),
		writeTable("Golay_23_12_7_table", tables.Golay23_12_7Encoding),
		jen.Line(),
		jen.Line(),
		writeTable("Golay_24_12_8_table", tables.Golay24_12_8Encoding),
		jen.Line(),
		jen.Line(),
		writeTable("golay_20_8_7_syndrome_table", tables.Golay20_8_7Syndrome[:]),
		jen.Line(),
		jen.Line(),
		writeTable("golay_23_12_7_syndrome_table", tables.Golay23_12_7Syndrome[:]),
		jen.Line(),
		jen.Line(),
		writeTable("golay_24_12_8_syndrome_table", tables.Golay24_12_8Syndrome[:]),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "fec/quadratic_residue", "quadratic_residue",
		writeTable("qr16_7_6_encoding_table", tables.QR16_7_6Encoding),
		jen.Line(),
		jen.Line(),
		writeTable("qr16_7_6_syndrome_table", tables.QR16_7_6Syndrome[:]),
	); err != nil {
		return err
	}

	if err := writeFile(dmrRoot, "fec/trellis", "trellis34",
		writeTable("encoder_state_transition_table", tables.EncoderStateTransition),
		jen.Line(),
		jen.Line(),
		writeTable("interleave_matrix", tables.InterleaveMatrix),
		jen.Line(),
		jen.Line(),
		writeTable2D("trellis34_transition_table", tables.Trellis34Transition),
		jen.Line(),
		jen.Line(),
		writeMap("trellis34_constellation", tables.ConstellationPoints),
		jen.Line(),
		jen.Line(),
		writeTable2D("trellis34_reverse_constellation", tables.ReverseConstellation),
	); err != nil {
		return err
	}

	return nil
}

func startFile(name string) *jen.File {
	f := jen.NewFile(name)
	f.HeaderComment("Code generated by github.com/USA-RedDragon/dmrgo/cmd/tablegen DO NOT EDIT.")
	return f
}

func writeFile(dmrRoot, dir, pkgName string, code ...jen.Code) error {
	f := startFile(pkgName)
	f.Add(code...)

	outPath := filepath.Join(dmrRoot, dir, "tables_gen.go")
	if err := f.Save(outPath); err != nil {
		return err
	}
	fmt.Println("wrote", outPath)
	return nil
}

func writeMap[K comparable, V any](name string, data map[K]V) jen.Code {
	var zeroK K
	var zeroV V

	keyType := typeToCode(reflect.TypeOf(zeroK))
	valType := typeToCode(reflect.TypeOf(zeroV))

	dict := jen.DictFunc(func(d jen.Dict) {
		for k, v := range data {
			d[valueToCode(reflect.ValueOf(k))] = valueToCode(reflect.ValueOf(v))
		}
	})

	return jen.Var().Id(name).Op("=").Map(keyType).Add(valType).Values(dict)
}

func typeToCode(t reflect.Type) jen.Code {
	switch t.Kind() { //nolint:exhaustive
	case reflect.Int:
		return jen.Int()
	case reflect.Int8:
		return jen.Int8()
	case reflect.Int16:
		return jen.Int16()
	case reflect.Int32:
		return jen.Int32()
	case reflect.Int64:
		return jen.Int64()
	case reflect.Uint8:
		return jen.Byte()
	case reflect.Uint16:
		return jen.Uint16()
	case reflect.Uint32:
		return jen.Uint32()
	case reflect.Uint64:
		return jen.Uint64()
	case reflect.Array:
		return jen.Index(jen.Lit(t.Len())).Add(typeToCode(t.Elem()))
	default:
		panic("unsupported type: " + t.String())
	}
}

func valueToCode(v reflect.Value) jen.Code {
	switch v.Kind() { //nolint:exhaustive
	case reflect.Array, reflect.Slice:
		elems := make([]jen.Code, v.Len())
		for i := range v.Len() {
			elems[i] = valueToCode(v.Index(i))
		}
		return jen.Values(elems...)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return jen.Lit(int(v.Int()))
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return jen.Lit(int(v.Uint())) //nolint:gosec
	default:
		panic("unsupported value kind: " + v.Kind().String())
	}
}

func writeTable[T ~byte | ~int | ~uint16 | ~uint32](name string, data []T) jen.Code {
	table := jen.Var().Id(name).Op("=").Index(jen.Lit(len(data))).Add(func() jen.Code {
		switch any(data).(type) {
		case []byte:
			return jen.Byte()
		case []int:
			return jen.Int()
		case []uint16:
			return jen.Uint16()
		case []uint32:
			return jen.Uint32()
		default:
			panic("unsupported type")
		}
	}())
	literals := make([]jen.Code, len(data))
	for i, b := range data {
		literals[i] = jen.Lit(int(b))
	}
	return table.Values(literals...)
}

func writeTable2D[T ~byte | ~int | ~int8 | ~uint16 | ~uint32](name string, data [][]T) jen.Code {
	if len(data) == 0 {
		return jen.Null()
	}
	innerLen := len(data[0])

	elemType := func() jen.Code {
		switch any(data[0]).(type) {
		case []byte:
			return jen.Byte()
		case []int:
			return jen.Int()
		case []int8:
			return jen.Int8()
		case []uint16:
			return jen.Uint16()
		case []uint32:
			return jen.Uint32()
		default:
			panic("unsupported type")
		}
	}()

	table := jen.Var().Id(name).Op("=").Index(jen.Lit(len(data))).Index(jen.Lit(innerLen)).Add(elemType)

	rows := make([]jen.Code, len(data))
	for i, row := range data {
		literals := make([]jen.Code, len(row))
		for j, val := range row {
			literals[j] = jen.Lit(int(val))
		}
		rows[i] = jen.Values(literals...)
	}

	return table.Values(rows...)
}
