// Package emit generates Go source code for PDU decode/encode functions
// using the jennifer code generation library.
package emit

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/USA-RedDragon/dmrgo/cmd/dmrgen/parse"
	. "github.com/dave/jennifer/jen" //nolint:revive,stylecheck,ST1001,staticcheck
)

const (
	bitPkg = "github.com/USA-RedDragon/dmrgo/dmr/bit"
	fecPkg = "github.com/USA-RedDragon/dmrgo/dmr/fec"
)

// FECCodecInfo maps FEC directive names to their decode function and import path.
type FECCodecInfo struct {
	ImportPath string // e.g. "github.com/USA-RedDragon/dmrgo/dmr/fec/golay"
	GoPkgName  string // actual Go package name (may differ from directory)
	DecodeFn   string // e.g. "DecodeGolay2087"
	EncodeFn   string // e.g. "Encode" â€” func(byte) [N]bit.Bit
	InputSize  int    // full FEC codeword size, e.g. 20
	DataBits   int    // data-only bits before FEC, e.g. 8
}

//nolint:gochecknoglobals
var fecCodecs = map[string]FECCodecInfo{
	"golay_20_8_7": {
		ImportPath: "github.com/USA-RedDragon/dmrgo/dmr/fec/golay",
		GoPkgName:  "golay",
		DecodeFn:   "DecodeGolay2087",
		EncodeFn:   "Encode",
		InputSize:  20,
		DataBits:   8,
	},
	"quadratic_residue_16_7_6": {
		ImportPath: "github.com/USA-RedDragon/dmrgo/dmr/fec/quadratic_residue",
		GoPkgName:  "quadratic_residue",
		DecodeFn:   "Decode",
		EncodeFn:   "Encode",
		InputSize:  16,
		DataBits:   7,
	},
}

// pkgNameOverrides maps import paths to actual Go package names where they differ
// from the directory name. Jennifer uses the last path element by default.
//
//nolint:gochecknoglobals
var pkgNameOverrides = map[string]string{
	"github.com/USA-RedDragon/dmrgo/dmr/fec/quadratic_residue": "quadratic_residue",
	"github.com/USA-RedDragon/dmrgo/dmr/fec/reed_solomon":      "reedsolomon",
	"github.com/USA-RedDragon/dmrgo/dmr/fec/trellis":           "trellis34",
}

// resolveImportPath converts a short package name (e.g. "enums") to a full import path.
func resolveImportPath(pkgName, sourceFile string) string {
	// Map well-known package names to full import paths
	knownPkgs := map[string]string{
		"enums":            "github.com/USA-RedDragon/dmrgo/dmr/enums",
		"elements":         "github.com/USA-RedDragon/dmrgo/dmr/layer2/elements",
		"bit":              "github.com/USA-RedDragon/dmrgo/dmr/bit",
		"fec":              "github.com/USA-RedDragon/dmrgo/dmr/fec",
		"layer3Elements":   "github.com/USA-RedDragon/dmrgo/dmr/layer3/elements",
		"golay":            "github.com/USA-RedDragon/dmrgo/dmr/fec/golay",
		"quadraticResidue": "github.com/USA-RedDragon/dmrgo/dmr/fec/quadratic_residue",
		"reedSolomon":      "github.com/USA-RedDragon/dmrgo/dmr/fec/reed_solomon",
		"bptc":             "github.com/USA-RedDragon/dmrgo/dmr/fec/bptc",
		"trellis":          "github.com/USA-RedDragon/dmrgo/dmr/fec/trellis",
	}
	if p, ok := knownPkgs[pkgName]; ok {
		return p
	}
	// Fall back: assume it's a relative sibling package
	dir := filepath.Dir(sourceFile)
	return "github.com/USA-RedDragon/dmrgo/" + filepath.Join(dir, pkgName)
}

// GenerateFile produces the _decode_gen.go content for a set of PDU structs.
func GenerateFile(pdus []parse.PDUStruct, pkgName string) (*File, error) {
	f := NewFile(pkgName)
	f.HeaderComment("Code generated by dmrgen. DO NOT EDIT.")

	// Register package name overrides so Jennifer uses the correct identifiers
	for importPath, pkgName := range pkgNameOverrides {
		f.ImportName(importPath, pkgName)
	}

	for _, pdu := range pdus {
		if err := emitDecode(f, pdu); err != nil {
			return nil, fmt.Errorf("generating decode for %s: %w", pdu.Name, err)
		}
		f.Line()
		emitEncode(f, pdu)
	}

	return f, nil
}

// emitDecode generates a DecodeXxx function for a PDU struct.
func emitDecode(f *File, pdu parse.PDUStruct) error {
	funcName := "Decode" + pdu.Name
	inputSize := pdu.InputSize

	// Determine if FEC pre-processing is needed
	var codec *FECCodecInfo
	if pdu.FEC != nil {
		c, ok := fecCodecs[pdu.FEC.Codec]
		if !ok {
			return fmt.Errorf("unknown FEC codec: %s", pdu.FEC.Codec)
		}
		codec = &c
		inputSize = codec.InputSize
	}

	// func DecodeXxx(data [N]bit.Bit) (Xxx, fec.FECResult) {
	f.Func().Id(funcName).Params(
		Id("data").Index(Lit(inputSize)).Qual(bitPkg, "Bit"),
	).Params(
		Id(pdu.Name),
		Qual(fecPkg, "FECResult"),
	).BlockFunc(func(g *Group) {
		g.Var().Id("result").Id(pdu.Name)

		if codec != nil {
			// FEC pre-processing:
			// corrected, fecResult := codec.Decode(data)
			// result.FEC = fecResult
			// if !fecResult.Uncorrectable { data = corrected }
			g.List(Id("corrected"), Id("fecResult")).Op(":=").Qual(codec.ImportPath, codec.DecodeFn).Call(Id("data"))
			g.Id("result").Dot("FEC").Op("=").Id("fecResult")
			g.If(Op("!").Id("fecResult").Dot("Uncorrectable")).Block(
				Id("data").Op("=").Id("corrected"),
			)
		} else {
			g.Var().Id("fecResult").Qual(fecPkg, "FECResult")
		}

		// Emit field extractions
		for _, field := range pdu.Fields {
			if field.Name == "FEC" {
				continue // skip the FEC field itself
			}
			emitFieldDecode(g, field, pdu)
		}

		g.Return(Id("result"), Id("fecResult"))
	})

	return nil
}

// emitFieldDecode generates the decode logic for a single field.
func emitFieldDecode(g *Group, field parse.Field, pdu parse.PDUStruct) {
	target := Id("result").Dot(field.Name)

	switch field.Kind {
	case parse.FieldBool:
		// result.FieldName = bit.BitsToBool(data[:], bitStart)
		g.Add(target).Op("=").Qual(bitPkg, "BitsToBool").Call(
			Id("data").Index(Empty(), Empty()),
			Lit(field.BitStart),
		)

	case parse.FieldUint:
		if len(field.ExtraBitRanges) > 0 {
			// Non-contiguous bits: accumulate segments MSB-first using a temp variable
			emitNonContiguousDecode(g, field, pdu)
		} else {
			// Choose the right bit extraction function based on width
			fn, castType := bitExtractFunc(field.BitWidth, field.GoType)
			call := Qual(bitPkg, fn).Call(
				Id("data").Index(Empty(), Empty()),
				Lit(field.BitStart),
				Lit(field.BitEnd-field.BitStart+1),
			)
			if needsCast(fn, field.GoType) {
				g.Add(target).Op("=").Add(qualType(field, pdu)).Call(call)
			} else {
				_ = castType
				g.Add(target).Op("=").Add(call)
			}
		}

	case parse.FieldInt:
		g.Add(target).Op("=").Qual(bitPkg, "BitsToInt").Call(
			Id("data").Index(Empty(), Empty()),
			Lit(field.BitStart),
			Lit(field.BitWidth),
		)

	case parse.FieldEnum:
		// Extract as int, then call FromInt
		extractExpr := Qual(bitPkg, "BitsToInt").Call(
			Id("data").Index(Empty(), Empty()),
			Lit(field.BitStart),
			Lit(field.BitWidth),
		)

		// Parse the FromInt function reference
		fromPkg, fromFn := splitQualified(field.EnumFromInt)
		importPath := resolveImportPath(fromPkg, pdu.SourceFile)

		// Check if FromInt returns error (two returns) or just value (one return)
		// We determine this from function name patterns:
		// LCSSFromInt returns just LCSS, FLCOFromInt returns (FLCO, error)
		if field.EnumReturnsErr {
			g.List(Id("_enumVal"), Id("_")).Op(":=").Qual(importPath, fromFn).Call(extractExpr)
			g.Add(target).Op("=").Id("_enumVal")
		} else {
			g.Add(target).Op("=").Qual(importPath, fromFn).Call(extractExpr)
		}

	case parse.FieldRaw:
		// Copy bits into a fixed-size array
		g.Copy(target.Clone().Index(Empty(), Empty()), Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)))

	case parse.FieldPacked:
		// Pack bits into bytes using bit.PackBits
		packed := Qual(bitPkg, "PackBits").Call(
			Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
		)
		if isFixedArray(field.GoType) {
			// Fixed-size array: must use copy
			g.Copy(target.Clone().Index(Empty(), Empty()), packed)
		} else {
			g.Add(target).Op("=").Add(packed)
		}

	case parse.FieldDelegate, parse.FieldLongitude, parse.FieldLatitude:
		// These field kinds are not yet implemented in the code generator.
		panic(fmt.Sprintf("emitFieldDecode: unsupported field kind %d for %s", field.Kind, field.Name))
	}
}

// emitEncode generates an EncodeXxx function for a PDU struct.
// For FEC-protected PDUs, the output includes FEC parity (full codeword).
func emitEncode(f *File, pdu parse.PDUStruct) {
	funcName := "Encode" + pdu.Name

	var codec *FECCodecInfo
	if pdu.FEC != nil {
		c, ok := fecCodecs[pdu.FEC.Codec]
		if ok {
			codec = &c
		}
	}

	// Output is the full FEC codeword size (or raw data size if no FEC)
	outputSize := pdu.InputSize
	if codec != nil {
		outputSize = codec.InputSize
	}

	f.Func().Id(funcName).Params(
		Id("s").Op("*").Id(pdu.Name),
	).Index(Lit(outputSize)).Qual(bitPkg, "Bit").BlockFunc(func(g *Group) {
		if codec != nil {
			// Build data bits in a temporary array, then FEC-encode
			dataBits := codec.DataBits
			g.Var().Id("data").Index(Lit(dataBits)).Qual(bitPkg, "Bit")

			for _, field := range pdu.Fields {
				if field.Name == "FEC" {
					continue
				}
				emitFieldEncode(g, field, pdu)
			}

			// Convert data bits to a byte value and apply FEC encoding
			g.Return(Qual(codec.ImportPath, codec.EncodeFn).Call(
				Qual(bitPkg, "BitsToValue").Call(Id("data").Index(Empty(), Empty())),
			))
		} else {
			g.Var().Id("data").Index(Lit(outputSize)).Qual(bitPkg, "Bit")

			for _, field := range pdu.Fields {
				if field.Name == "FEC" {
					continue
				}
				emitFieldEncode(g, field, pdu)
			}

			g.Return(Id("data"))
		}
	})
}

// emitFieldEncode generates the encode logic for a single field.
func emitFieldEncode(g *Group, field parse.Field, _ parse.PDUStruct) {
	source := Id("s").Dot(field.Name)

	switch field.Kind {
	case parse.FieldBool:
		// if s.FieldName { data[bit] = 1 }
		g.If(source.Clone()).Block(
			Id("data").Index(Lit(field.BitStart)).Op("=").Lit(1),
		)

	case parse.FieldUint:
		if len(field.ExtraBitRanges) > 0 {
			// Non-contiguous bits: decompose value into segments
			emitNonContiguousEncode(g, field)
		} else {
			fn := bitStoreFunc(field.BitWidth, field.GoType)
			bits := Qual(bitPkg, fn).Call(
				castToStoreFuncType(source.Clone(), field.GoType, fn),
				Lit(field.BitWidth),
			)
			g.Copy(
				Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
				bits,
			)
		}

	case parse.FieldInt:
		// BitsFromUint32 handles it, just needs a cast
		bits := Qual(bitPkg, "BitsFromUint32").Call(
			Uint32().Call(source.Clone()),
			Lit(field.BitWidth),
		)
		g.Copy(
			Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
			bits,
		)

	case parse.FieldEnum:
		// Cast enum to int, then to uint for BitsFromUint
		fn := bitStoreFunc(field.BitWidth, "uint8")
		storeType := storeParamType(fn)
		bits := Qual(bitPkg, fn).Call(
			Add(storeType).Call(source.Clone()),
			Lit(field.BitWidth),
		)
		g.Copy(
			Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
			bits,
		)

	case parse.FieldRaw:
		g.Copy(
			Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
			source.Clone().Index(Empty(), Empty()),
		)

	case parse.FieldPacked:
		// Unpack bytes back to individual bits
		var src *Statement
		if isFixedArray(field.GoType) {
			src = source.Clone().Index(Empty(), Empty()) // s.Data[:]
		} else {
			src = source.Clone()
		}
		g.Copy(
			Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
			Qual(bitPkg, "UnpackBits").Call(src),
		)

	case parse.FieldDelegate, parse.FieldLongitude, parse.FieldLatitude:
		// These field kinds are not yet implemented in the encoder.
		panic(fmt.Sprintf("emitFieldEncode: unsupported field kind %d for %s", field.Kind, field.Name))
	}
}

// emitNonContiguousDecode generates decode logic for a non-contiguous uint field.
// For example, bits:3+12-15 means bit 3 is the MSB and bits 12-15 are the lower nibble.
// It accumulates segments in a temp variable: extract first range, shift left, OR next range, etc.
func emitNonContiguousDecode(g *Group, field parse.Field, pdu parse.PDUStruct) {
	tmpName := "_tmp" + field.Name
	fn, _ := bitExtractFunc(field.BitWidth, field.GoType)
	firstWidth := field.BitEnd - field.BitStart + 1

	// var _tmpField uint8 (using the extract function's natural type)
	switch fn {
	case "BitsToUint8":
		g.Var().Id(tmpName).Uint8()
	case "BitsToUint16":
		g.Var().Id(tmpName).Uint16()
	default:
		g.Var().Id(tmpName).Uint32()
	}

	// _tmpField = BitsToUintN(data[:], firstStart, firstWidth)
	g.Id(tmpName).Op("=").Qual(bitPkg, fn).Call(
		Id("data").Index(Empty(), Empty()),
		Lit(field.BitStart),
		Lit(firstWidth),
	)

	// For each extra range: shift left by extra width, then OR the extracted bits
	for _, r := range field.ExtraBitRanges {
		extraWidth := r[1] - r[0] + 1
		g.Id(tmpName).Op("<<=").Lit(extraWidth)
		g.Id(tmpName).Op("|=").Qual(bitPkg, fn).Call(
			Id("data").Index(Empty(), Empty()),
			Lit(r[0]),
			Lit(extraWidth),
		)
	}

	// result.Field = cast(_tmpField)
	target := Id("result").Dot(field.Name)
	if needsCast(fn, field.GoType) {
		g.Add(target).Op("=").Add(qualType(field, pdu)).Call(Id(tmpName))
	} else {
		g.Add(target).Op("=").Id(tmpName)
	}
}

// emitNonContiguousEncode generates encode logic for a non-contiguous uint field.
// Decomposes the value into segments (MSB-first) and stores each in its bit range.
func emitNonContiguousEncode(g *Group, field parse.Field) {
	source := Id("s").Dot(field.Name)
	fn := bitStoreFunc(field.BitWidth, field.GoType)
	firstWidth := field.BitEnd - field.BitStart + 1

	// Calculate remaining bits after the first range
	remaining := 0
	for _, r := range field.ExtraBitRanges {
		remaining += r[1] - r[0] + 1
	}

	// First range: extract MSB portion by shifting right past remaining bits
	firstVal := castToStoreFuncType(source.Clone(), field.GoType, fn)
	if remaining > 0 {
		firstVal = castToStoreFuncType(
			Parens(Add(storeParamType(fn)).Call(source.Clone())).Op(">>").Lit(remaining),
			storeParamGoType(fn), fn,
		)
	}
	g.Copy(
		Id("data").Index(Lit(field.BitStart), Lit(field.BitEnd+1)),
		Qual(bitPkg, fn).Call(firstVal, Lit(firstWidth)),
	)

	// Each extra range: extract the corresponding portion
	for _, r := range field.ExtraBitRanges {
		extraWidth := r[1] - r[0] + 1
		remaining -= extraWidth

		var segVal *Statement
		if remaining > 0 {
			segVal = castToStoreFuncType(
				Parens(Add(storeParamType(fn)).Call(source.Clone())).Op(">>").Lit(remaining),
				storeParamGoType(fn), fn,
			)
		} else {
			segVal = castToStoreFuncType(source.Clone(), field.GoType, fn)
		}
		g.Copy(
			Id("data").Index(Lit(r[0]), Lit(r[1]+1)),
			Qual(bitPkg, fn).Call(segVal, Lit(extraWidth)),
		)
	}
}

// Helper functions

func bitExtractFunc(width int, _ string) (string, string) {
	switch {
	case width <= 8:
		return "BitsToUint8", "uint8"
	case width <= 16:
		return "BitsToUint16", "uint16"
	default:
		return "BitsToUint32", "uint32"
	}
}

func bitStoreFunc(width int, _ string) string {
	switch {
	case width <= 8:
		return "BitsFromUint8"
	case width <= 16:
		return "BitsFromUint16"
	default:
		return "BitsFromUint32"
	}
}

func storeParamType(fn string) *Statement {
	switch fn {
	case "BitsFromUint8":
		return Uint8()
	case "BitsFromUint16":
		return Uint16()
	default:
		return Uint32()
	}
}

// storeParamGoType returns the Go type string corresponding to a BitsFromUintN function.
func storeParamGoType(fn string) string {
	switch fn {
	case "BitsFromUint8":
		return "uint8"
	case "BitsFromUint16":
		return "uint16"
	default:
		return "uint32"
	}
}

func castToStoreFuncType(expr *Statement, goType, fn string) *Statement {
	expected := map[string]string{
		"BitsFromUint8":  "uint8",
		"BitsFromUint16": "uint16",
		"BitsFromUint32": "uint32",
	}
	if goType == expected[fn] {
		return expr
	}
	return Add(storeParamType(fn)).Call(expr)
}

func needsCast(extractFn, goType string) bool {
	switch extractFn {
	case "BitsToUint8":
		return goType != "uint8" && goType != "byte"
	case "BitsToUint16":
		return goType != "uint16"
	case "BitsToUint32":
		return goType != "uint32"
	case "BitsToInt":
		return goType != "int"
	}
	return false
}

func qualType(field parse.Field, pdu parse.PDUStruct) *Statement {
	if field.IsQualified {
		importPath := resolveImportPath(field.TypePkg, pdu.SourceFile)
		return Qual(importPath, field.TypeName)
	}
	return Id(field.GoType)
}

func splitQualified(s string) (string, string) {
	if idx := strings.LastIndex(s, "."); idx >= 0 {
		return s[:idx], s[idx+1:]
	}
	return "", s
}

// isFixedArray returns true if the Go type is a fixed-size array (e.g. "[12]byte")
// as opposed to a slice (e.g. "[]byte").
func isFixedArray(goType string) bool {
	return strings.HasPrefix(goType, "[") && !strings.HasPrefix(goType, "[]")
}
